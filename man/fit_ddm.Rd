% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_ddm.R
\name{fit_ddm}
\alias{fit_ddm}
\title{Fit drift-diffusion model}
\usage{
fit_ddm(
  drFormula,
  dat,
  bsFormula = bs ~ 1,
  ndtFormula = scaleLogisNDT ~ 1,
  biasFormula = bias ~ 1,
  ndtBound = "auto",
  priorIn = prior(normal(0, 1.5), nlpar = "scaleLogisNDT"),
  ...
)
}
\arguments{
\item{drFormula}{linear [mixed-effects] model formula defining drift rate}

\item{dat}{data frame}

\item{bsFormula}{linear [mixed-effects] model formula defining boundary separation}

\item{ndtFormula}{linear [mixed-effects] model formula defining non-decision time (NDT). NDT is estimated as a scaled logistic function, which helps with sampling.}

\item{biasFormula}{linear [mixed-effects] model formula defining bias}

\item{ndtBound}{The scalar numeric upper bound of the scaled logistic function defining NDT. Defaults to an upper bound that is the 5th percentile of the RT distribution (i.e., \code{quantile(rt,.05)}). If the model is not initializing successfully, reducing this value may help.}

\item{priorIn}{Priors to provide to the model. Note the default value which provides a reasonable prior over the possible values of NDT; if providing user-defined priors, it is recommended to also provide this one as well.}

\item{...}{}
}
\description{
Fits a 4-parameter drift-diffusion model using \code{\link[brms]{brm}},
with some adjusted defaults in order to make things somewhat easier for the user.
}
\details{
The primary change from the default \code{brms} implementation is estimating the NDT 
within a scaled logistic function. This provides natural boundaries, improves the 
chances that model initialization errors will not be encountered, and in preliminary tests
has helped restrict parameter trade-offs with other potential parameters of interest (e.g., drift rate).
If initialization errors are still encountered, it's recommended to decrease 
\code{init_r} (see \code{\link[brms]{brm}}).
}
\examples{

d <- TEfits::anstrain

## generate example response time data
d$absRat <- abs(d$ratio)
d$rt <- brms::rwiener(nrow(d)
,delta = .2 + d$absRat/5 + scale(d$trialNum)/20
, tau = .15
, alpha = 1 + sin(d$trialNum/20)/10
, beta = .5)[,'q']

d$drSpl <- bSplineMat(basisVar = d$trialNum, nbasis = 7)
d$bsSpl <- bSplineMat(basisVar = d$trialNum)

m_ddm <- fit_ddm(drFormula = rt | dec(acc) ~ scale(trialNum) +  (drSpl + scale(absRat) || subID)
 ,bsFormula = bs ~ (bsSpl || subID)
 ,dat = d
 , cores = 2 , chains = 2 # only run 2 chains for efficiency
 )

}
